= Truffle base API info

Abstract of a series of articles

== Node

Corresponds to AST Node.

=== execute

Evaluating methods should starts with `execute` and contains one argument of `VirtualFrame` type.

=== children

Field of subnodes must be marked by `@Child` annotations.
They cannot be final, as Truffle needs the capability to rewrite parts of the AST as it gathers profiling information about your code, hence the `@SuppressWarnings("FieldMayBeFinal")`.
However, during partial evaluation, they will be treated as effectively final, thanks to the `@Child` annotation.

[source,java]
----
public final class AdditionNode extends EasyScriptNode {
    @SuppressWarnings("FieldMayBeFinal")
    @Child
    private EasyScriptNode leftNode, rightNode;
}
----

=== RootNode

Entrypoint of interpretation.
It represents a callable AST.
RootNode does have an abstract `execute` method that you have to override

=== CallTarget

Invokable element, getting from rootNode instance.

They are used for:

* gathering profiling information about your code
* passing arbitrary arguments when performing the call, which allows the language to implement things like passing arguments from the command line to the entrypoint function, like Java does with the `String[]` parameters to the main method, for example
* and creating the `VirtualFrame` object that is passed to its underlying RootNode‘s execute method.

=== Specialization

Evaluation of AST node can be specialized by methods.
Needed methods will be chosen using information about argument type []

Example [https://docs.oracle.com/en/graalvm/jdk/17/docs/graalvm-as-a-platform/language-implementation-framework/TruffleLibraries/#strategy-1-specialization-per-representation]

[source,java]
----
abstract class ExpressionNode extends Node {
abstract Object execute(VirtualFrame frame);
}

@NodeChild @NodeChild
abstract class ArrayReadNode extends ExpressionNode {

    @Specialization
    int doBuffer(BufferArray array, int index) {
        return array.buffer[index];
    }

    @Specialization(guards = {"seq.stride == cachedStride",
                              "seq.start  == cachedStart"}, limit = "1")
    int doSequenceCached(SequenceArray seq, int index,
             @Cached("seq.start")  int cachedStart,
             @Cached("seq.stride") int cachedStride) {
        return cachedStart + cachedStride * index;
    }

    @Specialization
    int doSequence(SequenceArray seq, int index) {
        return seq.start + seq.stride * index;
    }
}
----

== DSL

Specialization will be automatically generated by the annotation processor.
Because annotation processors can only generate new Java classes, and not modify existing ones, we need to make the Node classes that use the DSL abstract, and the concrete class will be generated by the DSL.

=== Children

[source,java]
----
import com.oracle.truffle.api.dsl.NodeChild;

@NodeChild("leftNode")
@NodeChild("rightNode")
public abstract class AdditionNode extends EasyScriptNode {
    // ...

----

This tells the annotation processor that it should generate a Node class with two @Child fields, named leftNode and rightNode.
Since AdditionNode extends EasyScriptNode, the type of those fields will be EasyScriptNode – you can change that with the type attribute of the @NodeChild annotation.

== Variable Storage
